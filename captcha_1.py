# -*- coding: utf-8 -*-
"""captcha_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MwyJJynTL47FYN0vViGU4qsuT5OoWm2K

pip install tensorflow
pip install opencv
pip install requests
pip shutil
pip PIL
"""

from PIL import Image
from tensorflow.keras import backend as K
from tensorflow.keras.models import Sequential, load_model, Model

import glob
import numpy as np
import pandas as pd

import shutil
import requests
import time

import matplotlib.pyplot as plt

model_name = "0808_2"
model_path = '../models/{}.h5'.format(model_name)

IMGSAVEPATH = ''

url = 'https://www.bankoftianjin.com/pweb/GenTokenImg.do?random='
response = requests.get(url, stream=True)
with open( IMGSAVEPATH  + 'img.jpg', 'wb') as out_file:
    shutil.copyfileobj(response.raw, out_file)
del response
time.sleep(0)

print("save_completed")

image = Image.open(IMGSAVEPATH  + 'img.jpg')

image

CAPTCHA_CHARSET = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9','a', 'b', 'c',
                   'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 
                   'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', ] 
CAPTCHA_LEN = 4          
CAPTCHA_HEIGHT =  35       
CAPTCHA_WIDTH =   68

def rgb2gray(img):
    return np.dot(img[...,:3], [0.299, 0.587, 0.114])

def text2vec(text,length=CAPTCHA_LEN,charset=CAPTCHA_CHARSET):
    text_len = len(text)
    if text_len != length:
        raise ValueError("Error:length of captcha should be{},but got {}".format(length,text_len))
    vec = np.zeros(length*len(charset)) 
    for i in range(length):
        vec[charset.index(text[i]) + i*len(charset)] = 1
    return vec

def vec2text(vector):
    if not isinstance(vector, np.ndarray):
        vector = np.asarray(vector)
    vector = np.reshape(vector, [CAPTCHA_LEN, -1])
    text = ''
    for item in vector:
        text += CAPTCHA_CHARSET[np.argmax(item)]
    return text

def fit_keras_channels(batch, rows=CAPTCHA_HEIGHT, cols=CAPTCHA_WIDTH):
    if K.image_data_format() == 'channels_first':
        batch = batch.reshape(batch.shape[0], 1, rows, cols)
        input_shape = (1, rows, cols)
    else:
        batch = batch.reshape(batch.shape[0], rows, cols, 1)
        input_shape = (rows, cols, 1)
    
    return batch, input_shape

X_test = []
Y_test = []
Y_testfilename = []
for filename in glob.glob(IMGSAVEPATH  + 'img.jpg'):
    X_test.append(np.array(Image.open(filename)))
    Y_testfilename.append(filename)

# list -> rgb(numpy)
X_test = np.array(X_test, dtype=np.float32)
# rgb -> gray
X_test = rgb2gray(X_test)
# normalize
X_test = X_test / 255
# Fit keras channels
X_test, input_shape = fit_keras_channels(X_test)

model = load_model(model_path)

y_test_pred_prob = model.predict(X_test)
y_test_pred = vec2text(y_test_pred_prob)
Y_ans=Y_testfilename[-8:-4]
y_test_pred_df = pd.DataFrame({'id': np.array(Y_ans), 'class':y_test_pred}).sort_values(by='id')

image = Image.open(IMGSAVEPATH  + 'img.jpg')
plt.imshow(image)
plt.xlabel("prediction= "+y_test_pred)

